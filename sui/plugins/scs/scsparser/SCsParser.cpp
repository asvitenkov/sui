/** \file
 *  This C++ source file was generated by $ANTLR version 3.4
 *
 *     -  From the grammar source file : D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g
 *     -                            On : 2012-12-12 08:41:14
 *     -                for the parser : SCsParserParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C++ language generator and runtime by Gokulakannan Somasundaram ( heavy lifting from C Run-time by Jim Idle )
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Gokulakannan Somasundaram, ElectronDB
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "SCsParser.hpp"
/* ----------------------------------------- */


/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */

	namespace 	SCsParserNS  {

using namespace antlr3;
/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
ANTLR_UINT8*   SCsParserTokenNames[27+4]
     = {
        (ANTLR_UINT8*) "<invalid>",       /* String to print to indicate an invalid token */
        (ANTLR_UINT8*) "<EOR>",
        (ANTLR_UINT8*) "<DOWN>",
        (ANTLR_UINT8*) "<UP>",
        (ANTLR_UINT8*) "ALIASNONAME",
        (ANTLR_UINT8*) "ATTRSEP",
        (ANTLR_UINT8*) "CHARS",
        (ANTLR_UINT8*) "COMMENT",
        (ANTLR_UINT8*) "CONNECTORS",
        (ANTLR_UINT8*) "ELEMTYPE",
        (ANTLR_UINT8*) "LPAR",
        (ANTLR_UINT8*) "LPAR_INT",
        (ANTLR_UINT8*) "LPAR_OSET",
        (ANTLR_UINT8*) "LPAR_SET",
        (ANTLR_UINT8*) "LPAR_TRF",
        (ANTLR_UINT8*) "NAME",
        (ANTLR_UINT8*) "OBJSEP",
        (ANTLR_UINT8*) "RPAR",
        (ANTLR_UINT8*) "RPAR_INT",
        (ANTLR_UINT8*) "RPAR_OSET",
        (ANTLR_UINT8*) "RPAR_SET",
        (ANTLR_UINT8*) "RPAR_TRF",
        (ANTLR_UINT8*) "SENTSEP",
        (ANTLR_UINT8*) "SYNSEP",
        (ANTLR_UINT8*) "TRIPLESEP",
        (ANTLR_UINT8*) "UNICODE_CHAR",
        (ANTLR_UINT8*) "URL",
        (ANTLR_UINT8*) "WS",
        (ANTLR_UINT8*) "'/'",
        (ANTLR_UINT8*) "'\\\\['",
        (ANTLR_UINT8*) "'\\\\]'"
       };


/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g";

/** \brief Return the name of the grammar file that generated this code.
 */
const char* SCsParser::getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new SCsParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
SCsParser::SCsParser( StreamType* instream)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, NULL)

{
	// See if we can create a new parser with the standard constructor
	//
	this->init(instream);
}

/** \brief Create a new SCsParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
SCsParser::SCsParser( StreamType* instream, RecognizerSharedStateType* state)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, state)

{
	this->init(instream );
}

void SCsParser::init(StreamType* instream)
{
	/* Install the token table
	*/
	this->get_psrstate()->set_tokenNames( SCsParserTokenNames );


}

void
SCsParser::reset()
{
    this->get_rec()->reset();
}

/** Free the parser resources
 */
SCsParser::~SCsParser()
 {
}

/** Return token names used by this 
parser

 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static ANTLR_UINT8**	getTokenNames()
{
        return SCsParserTokenNames;
}


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_sentence_in_syntax80_bits[]	= { ANTLR_UINT64_LIT(0x0000000000400000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_sentence_in_syntax80( FOLLOW_sentence_in_syntax80_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_SENTSEP_in_syntax82_bits[]	= { ANTLR_UINT64_LIT(0x000000000400F612) };
static  SCsParserImplTraits::BitsetListType FOLLOW_SENTSEP_in_syntax82( FOLLOW_SENTSEP_in_syntax82_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_sentence_lv1_in_sentence107_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_sentence_lv1_in_sentence107( FOLLOW_sentence_lv1_in_sentence107_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_sentence_lv23456_in_sentence111_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_sentence_lv23456_in_sentence111( FOLLOW_sentence_lv23456_in_sentence111_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_idtf_in_sentence_lv23456129_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000100) };
static  SCsParserImplTraits::BitsetListType FOLLOW_idtf_in_sentence_lv23456129( FOLLOW_idtf_in_sentence_lv23456129_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_CONNECTORS_in_sentence_lv23456131_bits[]	= { ANTLR_UINT64_LIT(0x000000000400F610) };
static  SCsParserImplTraits::BitsetListType FOLLOW_CONNECTORS_in_sentence_lv23456131( FOLLOW_CONNECTORS_in_sentence_lv23456131_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_attrsList_in_sentence_lv23456133_bits[]	= { ANTLR_UINT64_LIT(0x000000000400F610) };
static  SCsParserImplTraits::BitsetListType FOLLOW_attrsList_in_sentence_lv23456133( FOLLOW_attrsList_in_sentence_lv23456133_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_objectList_in_sentence_lv23456135_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_objectList_in_sentence_lv23456135( FOLLOW_objectList_in_sentence_lv23456135_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_simpleIdtf_in_sentence_lv1153_bits[]	= { ANTLR_UINT64_LIT(0x0000000001000000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_simpleIdtf_in_sentence_lv1153( FOLLOW_simpleIdtf_in_sentence_lv1153_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_TRIPLESEP_in_sentence_lv1155_bits[]	= { ANTLR_UINT64_LIT(0x0000000004008200) };
static  SCsParserImplTraits::BitsetListType FOLLOW_TRIPLESEP_in_sentence_lv1155( FOLLOW_TRIPLESEP_in_sentence_lv1155_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_simpleIdtf_in_sentence_lv1157_bits[]	= { ANTLR_UINT64_LIT(0x0000000001000000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_simpleIdtf_in_sentence_lv1157( FOLLOW_simpleIdtf_in_sentence_lv1157_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_TRIPLESEP_in_sentence_lv1159_bits[]	= { ANTLR_UINT64_LIT(0x0000000004008200) };
static  SCsParserImplTraits::BitsetListType FOLLOW_TRIPLESEP_in_sentence_lv1159( FOLLOW_TRIPLESEP_in_sentence_lv1159_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_simpleIdtf_in_sentence_lv1161_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_simpleIdtf_in_sentence_lv1161( FOLLOW_simpleIdtf_in_sentence_lv1161_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_simpleIdtf_in_attrsList182_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000020) };
static  SCsParserImplTraits::BitsetListType FOLLOW_simpleIdtf_in_attrsList182( FOLLOW_simpleIdtf_in_attrsList182_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_ATTRSEP_in_attrsList184_bits[]	= { ANTLR_UINT64_LIT(0x0000000004008202) };
static  SCsParserImplTraits::BitsetListType FOLLOW_ATTRSEP_in_attrsList184( FOLLOW_ATTRSEP_in_attrsList184_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_idtfWithInt_in_objectList207_bits[]	= { ANTLR_UINT64_LIT(0x0000000000010002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_idtfWithInt_in_objectList207( FOLLOW_idtfWithInt_in_objectList207_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_OBJSEP_in_objectList210_bits[]	= { ANTLR_UINT64_LIT(0x000000000400F610) };
static  SCsParserImplTraits::BitsetListType FOLLOW_OBJSEP_in_objectList210( FOLLOW_OBJSEP_in_objectList210_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_idtfWithInt_in_objectList212_bits[]	= { ANTLR_UINT64_LIT(0x0000000000010002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_idtfWithInt_in_objectList212( FOLLOW_idtfWithInt_in_objectList212_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_CONNECTORS_in_intSentence240_bits[]	= { ANTLR_UINT64_LIT(0x000000000400F610) };
static  SCsParserImplTraits::BitsetListType FOLLOW_CONNECTORS_in_intSentence240( FOLLOW_CONNECTORS_in_intSentence240_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_attrsList_in_intSentence242_bits[]	= { ANTLR_UINT64_LIT(0x000000000400F610) };
static  SCsParserImplTraits::BitsetListType FOLLOW_attrsList_in_intSentence242( FOLLOW_attrsList_in_intSentence242_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_objectList_in_intSentence245_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_objectList_in_intSentence245( FOLLOW_objectList_in_intSentence245_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_LPAR_INT_in_intSentenceList263_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000100) };
static  SCsParserImplTraits::BitsetListType FOLLOW_LPAR_INT_in_intSentenceList263( FOLLOW_LPAR_INT_in_intSentenceList263_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_intSentence_in_intSentenceList267_bits[]	= { ANTLR_UINT64_LIT(0x0000000000400000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_intSentence_in_intSentenceList267( FOLLOW_intSentence_in_intSentenceList267_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_SENTSEP_in_intSentenceList269_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040100) };
static  SCsParserImplTraits::BitsetListType FOLLOW_SENTSEP_in_intSentenceList269( FOLLOW_SENTSEP_in_intSentenceList269_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_RPAR_INT_in_intSentenceList274_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_RPAR_INT_in_intSentenceList274( FOLLOW_RPAR_INT_in_intSentenceList274_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_intSentenceList_in_internal292_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_intSentenceList_in_internal292( FOLLOW_intSentenceList_in_internal292_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_LPAR_TRF_in_content324_bits[]	= { ANTLR_UINT64_LIT(0x0000000060208000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_LPAR_TRF_in_content324( FOLLOW_LPAR_TRF_in_content324_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_RPAR_TRF_in_content341_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_RPAR_TRF_in_content341( FOLLOW_RPAR_TRF_in_content341_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_LPAR_in_triple358_bits[]	= { ANTLR_UINT64_LIT(0x000000000400F610) };
static  SCsParserImplTraits::BitsetListType FOLLOW_LPAR_in_triple358( FOLLOW_LPAR_in_triple358_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_idtf_in_triple360_bits[]	= { ANTLR_UINT64_LIT(0x0000000000004000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_idtf_in_triple360( FOLLOW_idtf_in_triple360_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_content_in_triple362_bits[]	= { ANTLR_UINT64_LIT(0x000000000400F610) };
static  SCsParserImplTraits::BitsetListType FOLLOW_content_in_triple362( FOLLOW_content_in_triple362_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_idtf_in_triple364_bits[]	= { ANTLR_UINT64_LIT(0x0000000000020000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_idtf_in_triple364( FOLLOW_idtf_in_triple364_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_RPAR_in_triple366_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_RPAR_in_triple366( FOLLOW_RPAR_in_triple366_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_ALIASNONAME_in_alias383_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_ALIASNONAME_in_alias383( FOLLOW_ALIASNONAME_in_alias383_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_LPAR_SET_in_setIdtf400_bits[]	= { ANTLR_UINT64_LIT(0x000000000410F610) };
static  SCsParserImplTraits::BitsetListType FOLLOW_LPAR_SET_in_setIdtf400( FOLLOW_LPAR_SET_in_setIdtf400_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_attrsList_in_setIdtf403_bits[]	= { ANTLR_UINT64_LIT(0x000000000400F610) };
static  SCsParserImplTraits::BitsetListType FOLLOW_attrsList_in_setIdtf403( FOLLOW_attrsList_in_setIdtf403_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_idtfWithInt_in_setIdtf405_bits[]	= { ANTLR_UINT64_LIT(0x000000000411F610) };
static  SCsParserImplTraits::BitsetListType FOLLOW_idtfWithInt_in_setIdtf405( FOLLOW_idtfWithInt_in_setIdtf405_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_OBJSEP_in_setIdtf407_bits[]	= { ANTLR_UINT64_LIT(0x000000000410F610) };
static  SCsParserImplTraits::BitsetListType FOLLOW_OBJSEP_in_setIdtf407( FOLLOW_OBJSEP_in_setIdtf407_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_RPAR_SET_in_setIdtf415_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_RPAR_SET_in_setIdtf415( FOLLOW_RPAR_SET_in_setIdtf415_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_LPAR_OSET_in_osetIdtf433_bits[]	= { ANTLR_UINT64_LIT(0x000000000408F610) };
static  SCsParserImplTraits::BitsetListType FOLLOW_LPAR_OSET_in_osetIdtf433( FOLLOW_LPAR_OSET_in_osetIdtf433_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_attrsList_in_osetIdtf437_bits[]	= { ANTLR_UINT64_LIT(0x000000000400F610) };
static  SCsParserImplTraits::BitsetListType FOLLOW_attrsList_in_osetIdtf437( FOLLOW_attrsList_in_osetIdtf437_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_idtfWithInt_in_osetIdtf439_bits[]	= { ANTLR_UINT64_LIT(0x000000000409F610) };
static  SCsParserImplTraits::BitsetListType FOLLOW_idtfWithInt_in_osetIdtf439( FOLLOW_idtfWithInt_in_osetIdtf439_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_OBJSEP_in_osetIdtf441_bits[]	= { ANTLR_UINT64_LIT(0x000000000408F610) };
static  SCsParserImplTraits::BitsetListType FOLLOW_OBJSEP_in_osetIdtf441( FOLLOW_OBJSEP_in_osetIdtf441_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_RPAR_OSET_in_osetIdtf448_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_RPAR_OSET_in_osetIdtf448( FOLLOW_RPAR_OSET_in_osetIdtf448_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_simpleIdtf_in_anyIdtf475_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_simpleIdtf_in_anyIdtf475( FOLLOW_simpleIdtf_in_anyIdtf475_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_content_in_anyIdtf485_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_content_in_anyIdtf485( FOLLOW_content_in_anyIdtf485_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_triple_in_anyIdtf495_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_triple_in_anyIdtf495( FOLLOW_triple_in_anyIdtf495_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_setIdtf_in_anyIdtf505_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_setIdtf_in_anyIdtf505( FOLLOW_setIdtf_in_anyIdtf505_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_osetIdtf_in_anyIdtf515_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_osetIdtf_in_anyIdtf515( FOLLOW_osetIdtf_in_anyIdtf515_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_alias_in_anyIdtf525_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_alias_in_anyIdtf525( FOLLOW_alias_in_anyIdtf525_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_anyIdtf_in_idtf551_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_anyIdtf_in_idtf551( FOLLOW_anyIdtf_in_idtf551_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_ELEMTYPE_in_simpleIdtf569_bits[]	= { ANTLR_UINT64_LIT(0x0000000010000000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_ELEMTYPE_in_simpleIdtf569( FOLLOW_ELEMTYPE_in_simpleIdtf569_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_28_in_simpleIdtf571_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_28_in_simpleIdtf571( FOLLOW_28_in_simpleIdtf571_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_NAME_in_simpleIdtf576_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_NAME_in_simpleIdtf576( FOLLOW_NAME_in_simpleIdtf576_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_URL_in_simpleIdtf580_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_URL_in_simpleIdtf580( FOLLOW_URL_in_simpleIdtf580_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_idtf_in_idtfWithInt599_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000802) };
static  SCsParserImplTraits::BitsetListType FOLLOW_idtf_in_idtfWithInt599( FOLLOW_idtf_in_idtfWithInt599_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_internal_in_idtfWithInt601_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_internal_in_idtfWithInt601( FOLLOW_internal_in_idtfWithInt601_bits, 1 );


/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start syntax
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:52:1: syntax : ( sentence SENTSEP )* ;
 */
void
SCsParser::syntax()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:53:5: ( ( sentence SENTSEP )* )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:53:7: ( sentence SENTSEP )*
        {
            // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:53:7: ( sentence SENTSEP )*

            for (;;)
            {
                int alt1=2;
                switch ( this->LA(1) )
                {
                case ALIASNONAME:
                case ELEMTYPE:
                case LPAR:
                case LPAR_OSET:
                case LPAR_SET:
                case LPAR_TRF:
                case NAME:
                case URL:
                	{
                		alt1=1;
                	}
                    break;

                }

                switch (alt1)
                {
            	case 1:
            	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:53:9: sentence SENTSEP
            	    {
            	        this->followPush(FOLLOW_sentence_in_syntax80);
            	        sentence();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesyntaxEx;
            	        }


            	         this->matchToken(SENTSEP, &FOLLOW_SENTSEP_in_syntax82);
            	        if  (this->hasException())
            	        {
            	            goto rulesyntaxEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop1;	/* break out of the loop */
            	    break;
                }
            }
            loop1: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesyntaxEx; /* Prevent compiler warnings */
    rulesyntaxEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end syntax */

/**
 * $ANTLR start sentence
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:57:1: sentence : ( sentence_lv1 | sentence_lv23456 );
 */
void
SCsParser::sentence()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:58:5: ( sentence_lv1 | sentence_lv23456 )

            ANTLR_UINT32 alt2;

            alt2=2;

            switch ( this->LA(1) )
            {
            case ELEMTYPE:
            	{
            		switch ( this->LA(2) )
            		{
            		case 28:
            			{
            				switch ( this->LA(3) )
            				{
            				case NAME:
            					{
            						switch ( this->LA(4) )
            						{
            						case TRIPLESEP:
            							{
            								alt2=1;
            							}
            						    break;
            						case CONNECTORS:
            							{
            								alt2=2;
            							}
            						    break;

            						default:
            						    ExceptionBaseType* ex = new ANTLR_Exception< SCsParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            						    ex->set_decisionNum( 2 );
            						    ex->set_state( 2 );


            						    goto rulesentenceEx;

            						}

            					}
            				    break;

            				default:
            				    ExceptionBaseType* ex = new ANTLR_Exception< SCsParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            				    ex->set_decisionNum( 2 );
            				    ex->set_state( 5 );


            				    goto rulesentenceEx;

            				}

            			}
            		    break;

            		default:
            		    ExceptionBaseType* ex = new ANTLR_Exception< SCsParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		    ex->set_decisionNum( 2 );
            		    ex->set_state( 1 );


            		    goto rulesentenceEx;

            		}

            	}
                break;
            case NAME:
            	{
            		switch ( this->LA(2) )
            		{
            		case TRIPLESEP:
            			{
            				alt2=1;
            			}
            		    break;
            		case CONNECTORS:
            			{
            				alt2=2;
            			}
            		    break;

            		default:
            		    ExceptionBaseType* ex = new ANTLR_Exception< SCsParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		    ex->set_decisionNum( 2 );
            		    ex->set_state( 2 );


            		    goto rulesentenceEx;

            		}

            	}
                break;
            case URL:
            	{
            		switch ( this->LA(2) )
            		{
            		case TRIPLESEP:
            			{
            				alt2=1;
            			}
            		    break;
            		case CONNECTORS:
            			{
            				alt2=2;
            			}
            		    break;

            		default:
            		    ExceptionBaseType* ex = new ANTLR_Exception< SCsParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		    ex->set_decisionNum( 2 );
            		    ex->set_state( 3 );


            		    goto rulesentenceEx;

            		}

            	}
                break;
            case ALIASNONAME:
            case LPAR:
            case LPAR_OSET:
            case LPAR_SET:
            case LPAR_TRF:
            	{
            		alt2=2;
            	}
                break;

            default:
                ExceptionBaseType* ex = new ANTLR_Exception< SCsParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 2 );
                ex->set_state( 0 );


                goto rulesentenceEx;

            }

            switch (alt2)
            {
        	case 1:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:58:7: sentence_lv1
        	    {
        	        this->followPush(FOLLOW_sentence_lv1_in_sentence107);
        	        sentence_lv1();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesentenceEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:58:22: sentence_lv23456
        	    {
        	        this->followPush(FOLLOW_sentence_lv23456_in_sentence111);
        	        sentence_lv23456();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesentenceEx;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulesentenceEx; /* Prevent compiler warnings */
    rulesentenceEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end sentence */

/**
 * $ANTLR start sentence_lv23456
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:62:1: sentence_lv23456 : idtf CONNECTORS attrsList objectList ;
 */
void
SCsParser::sentence_lv23456()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:63:5: ( idtf CONNECTORS attrsList objectList )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:63:7: idtf CONNECTORS attrsList objectList
        {
            this->followPush(FOLLOW_idtf_in_sentence_lv23456129);
            idtf();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesentence_lv23456Ex;
            }


             this->matchToken(CONNECTORS, &FOLLOW_CONNECTORS_in_sentence_lv23456131);
            if  (this->hasException())
            {
                goto rulesentence_lv23456Ex;
            }


            this->followPush(FOLLOW_attrsList_in_sentence_lv23456133);
            attrsList();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesentence_lv23456Ex;
            }


            this->followPush(FOLLOW_objectList_in_sentence_lv23456135);
            objectList();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesentence_lv23456Ex;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesentence_lv23456Ex; /* Prevent compiler warnings */
    rulesentence_lv23456Ex: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end sentence_lv23456 */

/**
 * $ANTLR start sentence_lv1
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:67:1: sentence_lv1 : simpleIdtf TRIPLESEP simpleIdtf TRIPLESEP simpleIdtf ;
 */
void
SCsParser::sentence_lv1()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:68:5: ( simpleIdtf TRIPLESEP simpleIdtf TRIPLESEP simpleIdtf )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:68:7: simpleIdtf TRIPLESEP simpleIdtf TRIPLESEP simpleIdtf
        {
            this->followPush(FOLLOW_simpleIdtf_in_sentence_lv1153);
            simpleIdtf();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesentence_lv1Ex;
            }


             this->matchToken(TRIPLESEP, &FOLLOW_TRIPLESEP_in_sentence_lv1155);
            if  (this->hasException())
            {
                goto rulesentence_lv1Ex;
            }


            this->followPush(FOLLOW_simpleIdtf_in_sentence_lv1157);
            simpleIdtf();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesentence_lv1Ex;
            }


             this->matchToken(TRIPLESEP, &FOLLOW_TRIPLESEP_in_sentence_lv1159);
            if  (this->hasException())
            {
                goto rulesentence_lv1Ex;
            }


            this->followPush(FOLLOW_simpleIdtf_in_sentence_lv1161);
            simpleIdtf();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesentence_lv1Ex;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesentence_lv1Ex; /* Prevent compiler warnings */
    rulesentence_lv1Ex: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end sentence_lv1 */

/**
 * $ANTLR start attrsList
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:72:1: attrsList : ( simpleIdtf ATTRSEP )* ;
 */
void
SCsParser::attrsList()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:73:5: ( ( simpleIdtf ATTRSEP )* )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:73:8: ( simpleIdtf ATTRSEP )*
        {
            // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:73:8: ( simpleIdtf ATTRSEP )*

            for (;;)
            {
                int alt3=2;
                switch ( this->LA(1) )
                {
                case ELEMTYPE:
                	{
                		switch ( this->LA(2) )
                		{
                		case 28:
                			{
                				switch ( this->LA(3) )
                				{
                				case NAME:
                					{
                						switch ( this->LA(4) )
                						{
                						case ATTRSEP:
                							{
                								alt3=1;
                							}
                						    break;

                						}

                					}
                				    break;

                				}

                			}
                		    break;

                		}

                	}
                    break;
                case NAME:
                	{
                		switch ( this->LA(2) )
                		{
                		case ATTRSEP:
                			{
                				alt3=1;
                			}
                		    break;

                		}

                	}
                    break;
                case URL:
                	{
                		switch ( this->LA(2) )
                		{
                		case ATTRSEP:
                			{
                				alt3=1;
                			}
                		    break;

                		}

                	}
                    break;

                }

                switch (alt3)
                {
            	case 1:
            	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:73:9: simpleIdtf ATTRSEP
            	    {
            	        this->followPush(FOLLOW_simpleIdtf_in_attrsList182);
            	        simpleIdtf();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleattrsListEx;
            	        }


            	         this->matchToken(ATTRSEP, &FOLLOW_ATTRSEP_in_attrsList184);
            	        if  (this->hasException())
            	        {
            	            goto ruleattrsListEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop3;	/* break out of the loop */
            	    break;
                }
            }
            loop3: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleattrsListEx; /* Prevent compiler warnings */
    ruleattrsListEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end attrsList */

/**
 * $ANTLR start objectList
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:76:1: objectList : idtfWithInt ( OBJSEP idtfWithInt )* ;
 */
void
SCsParser::objectList()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:77:5: ( idtfWithInt ( OBJSEP idtfWithInt )* )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:77:7: idtfWithInt ( OBJSEP idtfWithInt )*
        {
            this->followPush(FOLLOW_idtfWithInt_in_objectList207);
            idtfWithInt();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleobjectListEx;
            }


            // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:77:19: ( OBJSEP idtfWithInt )*

            for (;;)
            {
                int alt4=2;
                switch ( this->LA(1) )
                {
                case OBJSEP:
                	{
                		alt4=1;
                	}
                    break;

                }

                switch (alt4)
                {
            	case 1:
            	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:77:20: OBJSEP idtfWithInt
            	    {
            	         this->matchToken(OBJSEP, &FOLLOW_OBJSEP_in_objectList210);
            	        if  (this->hasException())
            	        {
            	            goto ruleobjectListEx;
            	        }


            	        this->followPush(FOLLOW_idtfWithInt_in_objectList212);
            	        idtfWithInt();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleobjectListEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop4;	/* break out of the loop */
            	    break;
                }
            }
            loop4: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleobjectListEx; /* Prevent compiler warnings */
    ruleobjectListEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end objectList */

/**
 * $ANTLR start intSentence
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:81:1: intSentence : CONNECTORS attrsList objectList ;
 */
void
SCsParser::intSentence()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:82:5: ( CONNECTORS attrsList objectList )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:82:7: CONNECTORS attrsList objectList
        {
             this->matchToken(CONNECTORS, &FOLLOW_CONNECTORS_in_intSentence240);
            if  (this->hasException())
            {
                goto ruleintSentenceEx;
            }


            this->followPush(FOLLOW_attrsList_in_intSentence242);
            attrsList();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleintSentenceEx;
            }


            this->followPush(FOLLOW_objectList_in_intSentence245);
            objectList();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleintSentenceEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleintSentenceEx; /* Prevent compiler warnings */
    ruleintSentenceEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end intSentence */

/**
 * $ANTLR start intSentenceList
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:85:1: intSentenceList : LPAR_INT ( intSentence SENTSEP )+ RPAR_INT ;
 */
void
SCsParser::intSentenceList()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:86:5: ( LPAR_INT ( intSentence SENTSEP )+ RPAR_INT )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:86:7: LPAR_INT ( intSentence SENTSEP )+ RPAR_INT
        {
             this->matchToken(LPAR_INT, &FOLLOW_LPAR_INT_in_intSentenceList263);
            if  (this->hasException())
            {
                goto ruleintSentenceListEx;
            }


            // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:86:16: ( intSentence SENTSEP )+
            {
                int cnt5=0;

                for (;;)
                {
                    int alt5=2;
            	switch ( this->LA(1) )
            	{
            	case CONNECTORS:
            		{
            			alt5=1;
            		}
            	    break;

            	}

            	switch (alt5)
            	{
            	    case 1:
            	        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:86:18: intSentence SENTSEP
            	        {
            	            this->followPush(FOLLOW_intSentence_in_intSentenceList267);
            	            intSentence();

            	            this->followPop();
            	            if  (this->hasException())
            	            {
            	                goto ruleintSentenceListEx;
            	            }


            	             this->matchToken(SENTSEP, &FOLLOW_SENTSEP_in_intSentenceList269);
            	            if  (this->hasException())
            	            {
            	                goto ruleintSentenceListEx;
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt5 >= 1 )
            		{
            		    goto loop5;
            		}
            		/* mismatchedSetEx()
            		 */
            		new ANTLR_Exception< SCsParserImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


            		goto ruleintSentenceListEx;
            	}
            	cnt5++;
                }
                loop5: ;	/* Jump to here if this rule does not match */
            }

             this->matchToken(RPAR_INT, &FOLLOW_RPAR_INT_in_intSentenceList274);
            if  (this->hasException())
            {
                goto ruleintSentenceListEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleintSentenceListEx; /* Prevent compiler warnings */
    ruleintSentenceListEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end intSentenceList */

/**
 * $ANTLR start internal
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:89:1: internal : intSentenceList ;
 */
void
SCsParser::internal()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:90:5: ( intSentenceList )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:90:8: intSentenceList
        {
            this->followPush(FOLLOW_intSentenceList_in_internal292);
            intSentenceList();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleinternalEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleinternalEx; /* Prevent compiler warnings */
    ruleinternalEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end internal */

/**
 * $ANTLR start content
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:95:1: content : '[' ( NAME | '\\\\[' | '\\\\]' )* ']' ;
 */
void
SCsParser::content()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:96:5: ( '[' ( NAME | '\\\\[' | '\\\\]' )* ']' )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:96:8: '[' ( NAME | '\\\\[' | '\\\\]' )* ']'
        {
             this->matchToken(LPAR_TRF, &FOLLOW_LPAR_TRF_in_content324);
            if  (this->hasException())
            {
                goto rulecontentEx;
            }


            // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:96:12: ( NAME | '\\\\[' | '\\\\]' )*

            for (;;)
            {
                int alt6=2;
                switch ( this->LA(1) )
                {
                case NAME:
                case 29:
                case 30:
                	{
                		alt6=1;
                	}
                    break;

                }

                switch (alt6)
                {
            	case 1:
            	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:
            	    {
            	        if ( this->LA(1) == NAME || ((this->LA(1) >= 29) && (this->LA(1) <= 30)) )
            	        {
            	            this->consume();
            	            this->set_perror_recovery(false);
            	        }
            	        else
            	        {
            	            new ANTLR_Exception< SCsParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );
            	            this->get_exception()->set_expectingSet(NULL);

            	            goto rulecontentEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop6;	/* break out of the loop */
            	    break;
                }
            }
            loop6: ; /* Jump out to here if this rule does not match */


             this->matchToken(RPAR_TRF, &FOLLOW_RPAR_TRF_in_content341);
            if  (this->hasException())
            {
                goto rulecontentEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecontentEx; /* Prevent compiler warnings */
    rulecontentEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end content */

/**
 * $ANTLR start triple
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:99:1: triple : LPAR idtf content idtf RPAR ;
 */
void
SCsParser::triple()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:100:5: ( LPAR idtf content idtf RPAR )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:100:7: LPAR idtf content idtf RPAR
        {
             this->matchToken(LPAR, &FOLLOW_LPAR_in_triple358);
            if  (this->hasException())
            {
                goto ruletripleEx;
            }


            this->followPush(FOLLOW_idtf_in_triple360);
            idtf();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletripleEx;
            }


            this->followPush(FOLLOW_content_in_triple362);
            content();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletripleEx;
            }


            this->followPush(FOLLOW_idtf_in_triple364);
            idtf();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletripleEx;
            }


             this->matchToken(RPAR, &FOLLOW_RPAR_in_triple366);
            if  (this->hasException())
            {
                goto ruletripleEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletripleEx; /* Prevent compiler warnings */
    ruletripleEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end triple */

/**
 * $ANTLR start alias
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:103:1: alias : ALIASNONAME ;
 */
void
SCsParser::alias()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:104:5: ( ALIASNONAME )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:104:7: ALIASNONAME
        {
             this->matchToken(ALIASNONAME, &FOLLOW_ALIASNONAME_in_alias383);
            if  (this->hasException())
            {
                goto rulealiasEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulealiasEx; /* Prevent compiler warnings */
    rulealiasEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end alias */

/**
 * $ANTLR start setIdtf
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:107:1: setIdtf : LPAR_SET ( attrsList idtfWithInt ( OBJSEP )? )* RPAR_SET ;
 */
void
SCsParser::setIdtf()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:108:5: ( LPAR_SET ( attrsList idtfWithInt ( OBJSEP )? )* RPAR_SET )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:108:7: LPAR_SET ( attrsList idtfWithInt ( OBJSEP )? )* RPAR_SET
        {
             this->matchToken(LPAR_SET, &FOLLOW_LPAR_SET_in_setIdtf400);
            if  (this->hasException())
            {
                goto rulesetIdtfEx;
            }


            // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:108:16: ( attrsList idtfWithInt ( OBJSEP )? )*

            for (;;)
            {
                int alt8=2;
                switch ( this->LA(1) )
                {
                case ALIASNONAME:
                case ELEMTYPE:
                case LPAR:
                case LPAR_OSET:
                case LPAR_SET:
                case LPAR_TRF:
                case NAME:
                case URL:
                	{
                		alt8=1;
                	}
                    break;

                }

                switch (alt8)
                {
            	case 1:
            	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:108:17: attrsList idtfWithInt ( OBJSEP )?
            	    {
            	        this->followPush(FOLLOW_attrsList_in_setIdtf403);
            	        attrsList();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesetIdtfEx;
            	        }


            	        this->followPush(FOLLOW_idtfWithInt_in_setIdtf405);
            	        idtfWithInt();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesetIdtfEx;
            	        }


            	        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:108:39: ( OBJSEP )?
            	        {
            	            int alt7=2;
            	            switch ( this->LA(1) )
            	            {
            	                case OBJSEP:
            	                	{
            	                		alt7=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt7)
            	            {
            	        	case 1:
            	        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:108:39: OBJSEP
            	        	    {
            	        	         this->matchToken(OBJSEP, &FOLLOW_OBJSEP_in_setIdtf407);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulesetIdtfEx;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

            	default:
            	    goto loop8;	/* break out of the loop */
            	    break;
                }
            }
            loop8: ; /* Jump out to here if this rule does not match */


             this->matchToken(RPAR_SET, &FOLLOW_RPAR_SET_in_setIdtf415);
            if  (this->hasException())
            {
                goto rulesetIdtfEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesetIdtfEx; /* Prevent compiler warnings */
    rulesetIdtfEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end setIdtf */

/**
 * $ANTLR start osetIdtf
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:112:1: osetIdtf : LPAR_OSET ( attrsList idtfWithInt ( OBJSEP )? )* RPAR_OSET ;
 */
void
SCsParser::osetIdtf()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:113:5: ( LPAR_OSET ( attrsList idtfWithInt ( OBJSEP )? )* RPAR_OSET )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:113:7: LPAR_OSET ( attrsList idtfWithInt ( OBJSEP )? )* RPAR_OSET
        {
             this->matchToken(LPAR_OSET, &FOLLOW_LPAR_OSET_in_osetIdtf433);
            if  (this->hasException())
            {
                goto ruleosetIdtfEx;
            }


            // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:113:17: ( attrsList idtfWithInt ( OBJSEP )? )*

            for (;;)
            {
                int alt10=2;
                switch ( this->LA(1) )
                {
                case ALIASNONAME:
                case ELEMTYPE:
                case LPAR:
                case LPAR_OSET:
                case LPAR_SET:
                case LPAR_TRF:
                case NAME:
                case URL:
                	{
                		alt10=1;
                	}
                    break;

                }

                switch (alt10)
                {
            	case 1:
            	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:113:19: attrsList idtfWithInt ( OBJSEP )?
            	    {
            	        this->followPush(FOLLOW_attrsList_in_osetIdtf437);
            	        attrsList();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleosetIdtfEx;
            	        }


            	        this->followPush(FOLLOW_idtfWithInt_in_osetIdtf439);
            	        idtfWithInt();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleosetIdtfEx;
            	        }


            	        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:113:41: ( OBJSEP )?
            	        {
            	            int alt9=2;
            	            switch ( this->LA(1) )
            	            {
            	                case OBJSEP:
            	                	{
            	                		alt9=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt9)
            	            {
            	        	case 1:
            	        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:113:41: OBJSEP
            	        	    {
            	        	         this->matchToken(OBJSEP, &FOLLOW_OBJSEP_in_osetIdtf441);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleosetIdtfEx;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

            	default:
            	    goto loop10;	/* break out of the loop */
            	    break;
                }
            }
            loop10: ; /* Jump out to here if this rule does not match */


             this->matchToken(RPAR_OSET, &FOLLOW_RPAR_OSET_in_osetIdtf448);
            if  (this->hasException())
            {
                goto ruleosetIdtfEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleosetIdtfEx; /* Prevent compiler warnings */
    ruleosetIdtfEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end osetIdtf */

/**
 * $ANTLR start anyIdtf
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:116:1: anyIdtf : ( simpleIdtf | content | triple | setIdtf | osetIdtf | alias );
 */
void
SCsParser::anyIdtf()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:117:5: ( simpleIdtf | content | triple | setIdtf | osetIdtf | alias )

            ANTLR_UINT32 alt11;

            alt11=6;

            switch ( this->LA(1) )
            {
            case ELEMTYPE:
            case NAME:
            case URL:
            	{
            		alt11=1;
            	}
                break;
            case LPAR_TRF:
            	{
            		alt11=2;
            	}
                break;
            case LPAR:
            	{
            		alt11=3;
            	}
                break;
            case LPAR_SET:
            	{
            		alt11=4;
            	}
                break;
            case LPAR_OSET:
            	{
            		alt11=5;
            	}
                break;
            case ALIASNONAME:
            	{
            		alt11=6;
            	}
                break;

            default:
                ExceptionBaseType* ex = new ANTLR_Exception< SCsParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 11 );
                ex->set_state( 0 );


                goto ruleanyIdtfEx;

            }

            switch (alt11)
            {
        	case 1:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:118:9: simpleIdtf
        	    {
        	        this->followPush(FOLLOW_simpleIdtf_in_anyIdtf475);
        	        simpleIdtf();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleanyIdtfEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:119:9: content
        	    {
        	        this->followPush(FOLLOW_content_in_anyIdtf485);
        	        content();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleanyIdtfEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:120:9: triple
        	    {
        	        this->followPush(FOLLOW_triple_in_anyIdtf495);
        	        triple();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleanyIdtfEx;
        	        }


        	    }
        	    break;
        	case 4:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:121:9: setIdtf
        	    {
        	        this->followPush(FOLLOW_setIdtf_in_anyIdtf505);
        	        setIdtf();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleanyIdtfEx;
        	        }


        	    }
        	    break;
        	case 5:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:122:9: osetIdtf
        	    {
        	        this->followPush(FOLLOW_osetIdtf_in_anyIdtf515);
        	        osetIdtf();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleanyIdtfEx;
        	        }


        	    }
        	    break;
        	case 6:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:123:9: alias
        	    {
        	        this->followPush(FOLLOW_alias_in_anyIdtf525);
        	        alias();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleanyIdtfEx;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruleanyIdtfEx; /* Prevent compiler warnings */
    ruleanyIdtfEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end anyIdtf */

/**
 * $ANTLR start idtf
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:127:1: idtf : anyIdtf ;
 */
void
SCsParser::idtf()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:128:5: ( anyIdtf )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:128:7: anyIdtf
        {
            this->followPush(FOLLOW_anyIdtf_in_idtf551);
            anyIdtf();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleidtfEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleidtfEx; /* Prevent compiler warnings */
    ruleidtfEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end idtf */

/**
 * $ANTLR start simpleIdtf
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:131:1: simpleIdtf : ( ( ELEMTYPE '/' )? NAME | URL );
 */
void
SCsParser::simpleIdtf()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:131:13: ( ( ELEMTYPE '/' )? NAME | URL )

            ANTLR_UINT32 alt13;

            alt13=2;

            switch ( this->LA(1) )
            {
            case ELEMTYPE:
            case NAME:
            	{
            		alt13=1;
            	}
                break;
            case URL:
            	{
            		alt13=2;
            	}
                break;

            default:
                ExceptionBaseType* ex = new ANTLR_Exception< SCsParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 13 );
                ex->set_state( 0 );


                goto rulesimpleIdtfEx;

            }

            switch (alt13)
            {
        	case 1:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:132:4: ( ELEMTYPE '/' )? NAME
        	    {
        	        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:132:4: ( ELEMTYPE '/' )?
        	        {
        	            int alt12=2;
        	            switch ( this->LA(1) )
        	            {
        	                case ELEMTYPE:
        	                	{
        	                		alt12=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt12)
        	            {
        	        	case 1:
        	        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:132:5: ELEMTYPE '/'
        	        	    {
        	        	         this->matchToken(ELEMTYPE, &FOLLOW_ELEMTYPE_in_simpleIdtf569);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulesimpleIdtfEx;
        	        	        }


        	        	         this->matchToken(28, &FOLLOW_28_in_simpleIdtf571);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulesimpleIdtfEx;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	         this->matchToken(NAME, &FOLLOW_NAME_in_simpleIdtf576);
        	        if  (this->hasException())
        	        {
        	            goto rulesimpleIdtfEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:132:28: URL
        	    {
        	         this->matchToken(URL, &FOLLOW_URL_in_simpleIdtf580);
        	        if  (this->hasException())
        	        {
        	            goto rulesimpleIdtfEx;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulesimpleIdtfEx; /* Prevent compiler warnings */
    rulesimpleIdtfEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end simpleIdtf */

/**
 * $ANTLR start idtfWithInt
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:137:1: idtfWithInt : idtf ( internal )? ;
 */
void
SCsParser::idtfWithInt()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:138:5: ( idtf ( internal )? )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:138:8: idtf ( internal )?
        {
            this->followPush(FOLLOW_idtf_in_idtfWithInt599);
            idtf();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleidtfWithIntEx;
            }


            // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:138:13: ( internal )?
            {
                int alt14=2;
                switch ( this->LA(1) )
                {
                    case LPAR_INT:
                    	{
                    		alt14=1;
                    	}
                        break;
                }

                switch (alt14)
                {
            	case 1:
            	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:138:13: internal
            	    {
            	        this->followPush(FOLLOW_internal_in_idtfWithInt601);
            	        internal();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleidtfWithIntEx;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleidtfWithIntEx; /* Prevent compiler warnings */
    ruleidtfWithIntEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end idtfWithInt */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */

	}


/* End of code
 * =============================================================================
 */
